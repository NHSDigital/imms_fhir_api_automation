{"uid":"d2c2dd53154aa6d7","name":"Verify that minimum dataset vaccination record will be created through batch file","fullName":"features.batchTests.Steps.test_create_batch_steps#test_verify_that_minimum_dataset_vaccination_record_will_be_created_through_batch_file","historyId":"a2ca749468eabcb18ccffad9519d20e5","time":{"start":1765550047589,"stop":1765550047591,"duration":2},"description":"/home/runner/work/imms_fhir_api_automation/imms_fhir_api_automation/features/batchTests/create_batch.feature: Verify that minimum dataset vaccination record will be created through batch file","descriptionHtml":"<p>/home/runner/work/imms_fhir_api_automation/imms_fhir_api_automation/features/batchTests/create_batch.feature: Verify that minimum dataset vaccination record will be created through batch file</p>\n","status":"broken","statusMessage":"requests.exceptions.InvalidURL: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize","statusTrace":"url = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n>               host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\nE               AttributeError: 'NoneType' object has no attribute 'groups'\n\nvenv/lib/python3.11/site-packages/urllib3/util/url.py:423: AttributeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <PreparedRequest [GET]>\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\nparams = OrderedDict([('client_id', 'FPY3m1CmiUYjFSYrbvhOcF91fU5K2W8J'), ('redirect_uri', 'https://oauth.pstmn.io/v1/callback'), ('response_type', 'code'), ('scope', 'nhs-cis2'), ('state', '06345f81-1e45-4685-ac4c-d7769842d3a7')])\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n>           scheme, auth, host, port, path, query, fragment = parse_url(url)\n\nvenv/lib/python3.11/site-packages/requests/models.py:433: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n                host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n                if auth and normalize_uri:\n                    auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n                if port == \"\":\n                    port = None\n            else:\n                auth, host, port = None, None, None\n    \n            if port is not None:\n                port_int = int(port)\n                if not (0 <= port_int <= 65535):\n                    raise LocationParseError(url)\n            else:\n                port_int = None\n    \n            host = _normalize_host(host, scheme)\n    \n            if normalize_uri and path:\n                path = _remove_path_dot_segments(path)\n                path = _encode_invalid_chars(path, _PATH_CHARS)\n            if normalize_uri and query:\n                query = _encode_invalid_chars(query, _QUERY_CHARS)\n            if normalize_uri and fragment:\n                fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n    \n        except (ValueError, AttributeError) as e:\n>           raise LocationParseError(source_url) from e\nE           urllib3.exceptions.LocationParseError: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize\n\nvenv/lib/python3.11/site-packages/urllib3/util/url.py:449: LocationParseError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <HookCaller 'pytest_bdd_after_scenario'>\nkwargs = {'feature': Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch...nd=None)], description='', tags={'smoke', 'vaccine_type_MMR', 'supplier_name_TPP', 'delete_cleanup_batch'}, rule=None)}\nfirstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\nvenv/lib/python3.11/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nfeatures/conftest.py:80: in pytest_bdd_after_scenario\n    context = request.getfixturevalue('context')\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:532: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:617: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:1071: in execute\n    raise exc.with_traceback(exc_tb)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:1140: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:898: in call_fixture_func\n    fixture_result = fixturefunc(**kwargs)\nfeatures/conftest.py:72: in context\n    get_tokens(ctx, ctx.supplier_name)\nutilities/api_gen_token.py:89: in get_tokens\n    context.token = get_access_token(context)\nutilities/api_gen_token.py:28: in get_access_token\n    authorize_resp = login_session.get(\nvenv/lib/python3.11/site-packages/requests/sessions.py:602: in get\n    return self.request(\"GET\", url, **kwargs)\nvenv/lib/python3.11/site-packages/requests/sessions.py:575: in request\n    prep = self.prepare_request(req)\nvenv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request\n    p.prepare(\nvenv/lib/python3.11/site-packages/requests/models.py:367: in prepare\n    self.prepare_url(url, params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <PreparedRequest [GET]>\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\nparams = OrderedDict([('client_id', 'FPY3m1CmiUYjFSYrbvhOcF91fU5K2W8J'), ('redirect_uri', 'https://oauth.pstmn.io/v1/callback'), ('response_type', 'code'), ('scope', 'nhs-cis2'), ('state', '06345f81-1e45-4685-ac4c-d7769842d3a7')])\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n            scheme, auth, host, port, path, query, fragment = parse_url(url)\n        except LocationParseError as e:\n>           raise InvalidURL(*e.args)\nE           requests.exceptions.InvalidURL: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize\n\nvenv/lib/python3.11/site-packages/requests/models.py:435: InvalidURL","flaky":false,"newFailed":false,"newBroken":true,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"setup_environment","time":{"start":1765550041771,"stop":1765550041771,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"global_context","time":{"start":1765550041774,"stop":1765550043555,"duration":1781},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"_pytest_bdd_example","time":{"start":1765550047589,"stop":1765550047589,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"/home/runner/work/imms_fhir_api_automation/imms_fhir_api_automation/features/batchTests/create_batch.feature: Verify that minimum dataset vaccination record will be created through batch file","status":"broken","statusMessage":"requests.exceptions.InvalidURL: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize","statusTrace":"url = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n>               host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\nE               AttributeError: 'NoneType' object has no attribute 'groups'\n\nvenv/lib/python3.11/site-packages/urllib3/util/url.py:423: AttributeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <PreparedRequest [GET]>\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\nparams = OrderedDict([('client_id', 'FPY3m1CmiUYjFSYrbvhOcF91fU5K2W8J'), ('redirect_uri', 'https://oauth.pstmn.io/v1/callback'), ('response_type', 'code'), ('scope', 'nhs-cis2'), ('state', '06345f81-1e45-4685-ac4c-d7769842d3a7')])\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n>           scheme, auth, host, port, path, query, fragment = parse_url(url)\n\nvenv/lib/python3.11/site-packages/requests/models.py:433: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n                host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n                if auth and normalize_uri:\n                    auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n                if port == \"\":\n                    port = None\n            else:\n                auth, host, port = None, None, None\n    \n            if port is not None:\n                port_int = int(port)\n                if not (0 <= port_int <= 65535):\n                    raise LocationParseError(url)\n            else:\n                port_int = None\n    \n            host = _normalize_host(host, scheme)\n    \n            if normalize_uri and path:\n                path = _remove_path_dot_segments(path)\n                path = _encode_invalid_chars(path, _PATH_CHARS)\n            if normalize_uri and query:\n                query = _encode_invalid_chars(query, _QUERY_CHARS)\n            if normalize_uri and fragment:\n                fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n    \n        except (ValueError, AttributeError) as e:\n>           raise LocationParseError(source_url) from e\nE           urllib3.exceptions.LocationParseError: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize\n\nvenv/lib/python3.11/site-packages/urllib3/util/url.py:449: LocationParseError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <HookCaller 'pytest_bdd_after_scenario'>\nkwargs = {'feature': Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch...nd=None)], description='', tags={'smoke', 'vaccine_type_MMR', 'supplier_name_TPP', 'delete_cleanup_batch'}, rule=None)}\nfirstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\nvenv/lib/python3.11/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nfeatures/conftest.py:80: in pytest_bdd_after_scenario\n    context = request.getfixturevalue('context')\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:532: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:617: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:1071: in execute\n    raise exc.with_traceback(exc_tb)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:1140: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\nvenv/lib/python3.11/site-packages/_pytest/fixtures.py:898: in call_fixture_func\n    fixture_result = fixturefunc(**kwargs)\nfeatures/conftest.py:72: in context\n    get_tokens(ctx, ctx.supplier_name)\nutilities/api_gen_token.py:89: in get_tokens\n    context.token = get_access_token(context)\nutilities/api_gen_token.py:28: in get_access_token\n    authorize_resp = login_session.get(\nvenv/lib/python3.11/site-packages/requests/sessions.py:602: in get\n    return self.request(\"GET\", url, **kwargs)\nvenv/lib/python3.11/site-packages/requests/sessions.py:575: in request\n    prep = self.prepare_request(req)\nvenv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request\n    p.prepare(\nvenv/lib/python3.11/site-packages/requests/models.py:367: in prepare\n    self.prepare_url(url, params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <PreparedRequest [GET]>\nurl = 'https://%s.api.service.nhs.uk/oauth2-mock/authorize'\nparams = OrderedDict([('client_id', 'FPY3m1CmiUYjFSYrbvhOcF91fU5K2W8J'), ('redirect_uri', 'https://oauth.pstmn.io/v1/callback'), ('response_type', 'code'), ('scope', 'nhs-cis2'), ('state', '06345f81-1e45-4685-ac4c-d7769842d3a7')])\n\n    def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n    \n        # Remove leading whitespaces from url\n        url = url.lstrip()\n    \n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n    \n        # Support for unicode domain names and paths.\n        try:\n            scheme, auth, host, port, path, query, fragment = parse_url(url)\n        except LocationParseError as e:\n>           raise InvalidURL(*e.args)\nE           requests.exceptions.InvalidURL: Failed to parse: https://%s.api.service.nhs.uk/oauth2-mock/authorize\n\nvenv/lib/python3.11/site-packages/requests/models.py:435: InvalidURL","steps":[],"attachments":[{"uid":"2f5ec9916cba7c4","name":"Step Failed: batch file is created for below data as minimum dataset","source":"2f5ec9916cba7c4.txt","type":"text/plain","size":154}],"parameters":[],"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"epic","value":"Immunization Service"},{"name":"suite","value":"Create the immunization event for a patient through batch file"},{"name":"feature","value":"Create the immunization event for a patient through batch file"},{"name":"tag","value":"functional"},{"name":"tag","value":"supplier_name_TPP"},{"name":"tag","value":"smoke"},{"name":"tag","value":"delete_cleanup_batch"},{"name":"tag","value":"Create_Batch_Feature"},{"name":"tag","value":"vaccine_type_MMR"},{"name":"parentSuite","value":"features.batchTests.Steps"},{"name":"host","value":"runnervm6qbrg"},{"name":"thread","value":"2538-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"features.batchTests.Steps.test_create_batch_steps"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":2,"broken":4,"skipped":0,"passed":8,"unknown":0,"total":14},"items":[{"uid":"68f8f8a5399276d4","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/181/#testresult/68f8f8a5399276d4","status":"passed","time":{"start":1765546414985,"stop":1765546467565,"duration":52580}},{"uid":"27a9baaf256d3f6c","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/183/#testresult/27a9baaf256d3f6c","status":"broken","statusDetails":"requests.exceptions.InvalidURL: URL has an invalid label.","time":{"start":1765546769070,"stop":1765546769072,"duration":2}},{"uid":"8434759d4b8743b4","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/180/#testresult/8434759d4b8743b4","status":"broken","statusDetails":"requests.exceptions.InvalidURL: URL has an invalid label.","time":{"start":1765545422054,"stop":1765545422057,"duration":3}},{"uid":"98962b2cbcf74123","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/179/#testresult/98962b2cbcf74123","status":"passed","time":{"start":1765466339822,"stop":1765466400291,"duration":60469}},{"uid":"371e63379759d485","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/178/#testresult/371e63379759d485","status":"passed","time":{"start":1765399198831,"stop":1765399243526,"duration":44695}},{"uid":"c08d92480fe3472a","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/176/#testresult/c08d92480fe3472a","status":"passed","time":{"start":1765385488863,"stop":1765385545015,"duration":56152}},{"uid":"ca51fab61dc0a9a0","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/175/#testresult/ca51fab61dc0a9a0","status":"passed","time":{"start":1765001210902,"stop":1765001263053,"duration":52151}},{"uid":"4ce1237dbb7f7ae6","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/174/#testresult/4ce1237dbb7f7ae6","status":"failed","statusDetails":"AssertionError: FAILURE: check bool(False): No rows with non-null IMMS_ID found in vaccine_df\nfeatures/batchTests/Steps/batch_common_steps.py:164 in validate_imms_event_table_for_all_records_in_batch_file() -> check.is_true(not valid_rows.empty, \"No rows with non-null IMMS_ID found in vaccine_df\")\n\nFAILURE: check bool(False): No rows with non-null IMMS_ID found in vaccine_df\n------------------------------------------------------------\nFailed Checks: 2\n------------------------------------------------------------\nself = <HookCaller 'pytest_bdd_after_scenario'>\nkwargs = {'feature': Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch...nd=None)], description='', tags={'smoke', 'delete_cleanup_batch', 'vaccine_type_MMR', 'supplier_name_TPP'}, rule=None)}\nfirstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\nvenv/lib/python3.11/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrequest = <FixtureRequest for <Function test_verify_that_minimum_dataset_vaccination_record_will_be_created_through_batch_file>>\nfeature = Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch file', Scen...tient through batch file', tags={'functional', 'Create_Batch_Feature'}, background=None, line_number=2, description='')\nscenario = Scenario(feature=Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through ...und=None)], description='', tags={'smoke', 'delete_cleanup_batch', 'vaccine_type_MMR', 'supplier_name_TPP'}, rule=None)\n\n    def pytest_bdd_after_scenario(request, feature, scenario):\n        tags = set(getattr(scenario, 'tags', [])) | set(getattr(feature, 'tags', []))\n        context = request.getfixturevalue('context')\n        get_delete_url_header(context)\n    \n        if 'Delete_cleanUp' in tags:\n            print(f\"\\n Delete Request is {context.url}/{context.ImmsID}\")\n            context.response = requests.delete(f\"{context.url}/{context.ImmsID}\", headers=context.headers)\n            assert context.response.status_code == 204, f\"Expected status code 204, but got {context.response.status_code}. Response: {context.response.json()}\"\n    \n        if 'delete_cleanup_batch' in tags:\n            get_tokens(context, context.supplier_name)\n            context.vaccine_df[\"IMMS_ID_CLEAN\"] = context.vaccine_df[\"IMMS_ID\"].astype(str).str.replace(\"Immunization#\", \"\", regex=False)\n    \n            for imms_id in context.vaccine_df[\"IMMS_ID_CLEAN\"].dropna().unique():\n                delete_url = f\"{context.url}/{imms_id}\"\n                print(f\"Sending DELETE request to: {delete_url}\")\n                response = requests.delete(delete_url, headers=context.headers)\n    \n>               assert response.status_code == 204, (\n                    f\" Failed to delete {imms_id}: expected 204, got {response.status_code}. \"\n                    f\"Response: {response.text}\"\n                )\nE               AssertionError:  Failed to delete nan: expected 204, got 404. Response: {\"resourceType\": \"OperationOutcome\", \"id\": \"a1b3be4a-4987-41ca-8dc4-52ee5f39922f\", \"meta\": {\"profile\": [\"https://simplifier.net/guide/UKCoreDevelopment2/ProfileUKCore-OperationOutcome\"]}, \"issue\": [{\"severity\": \"error\", \"code\": \"not-found\", \"details\": {\"coding\": [{\"system\": \"https://fhir.nhs.uk/Codesystem/http-error-codes\", \"code\": \"NOT-FOUND\"}]}, \"diagnostics\": \"Immunization resource does not exist. ID: nan\"}]}\nE               assert 404 == 204\nE                +  where 404 = <Response [404]>.status_code\n\nfeatures/conftest.py:97: AssertionError","time":{"start":1764973063845,"stop":1764973107932,"duration":44087}},{"uid":"f90f8bd355bc524f","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/172/#testresult/f90f8bd355bc524f","status":"failed","statusDetails":"AssertionError: FAILURE: check bool(False): No rows with non-null IMMS_ID found in vaccine_df\nfeatures/batchTests/Steps/batch_common_steps.py:164 in validate_imms_event_table_for_all_records_in_batch_file() -> check.is_true(not valid_rows.empty, \"No rows with non-null IMMS_ID found in vaccine_df\")\n\nFAILURE: check bool(False): No rows with non-null IMMS_ID found in vaccine_df\n------------------------------------------------------------\nFailed Checks: 2\n------------------------------------------------------------\nself = <HookCaller 'pytest_bdd_after_scenario'>\nkwargs = {'feature': Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch...nd=None)], description='', tags={'delete_cleanup_batch', 'vaccine_type_MMR', 'smoke', 'supplier_name_TPP'}, rule=None)}\nfirstresult = False\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n    \n        Only accepts keyword arguments, which should match the hook\n        specification.\n    \n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\nvenv/lib/python3.11/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv/lib/python3.11/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrequest = <FixtureRequest for <Function test_verify_that_minimum_dataset_vaccination_record_will_be_created_through_batch_file>>\nfeature = Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through batch file', Scen...tient through batch file', tags={'Create_Batch_Feature', 'functional'}, background=None, line_number=2, description='')\nscenario = Scenario(feature=Feature(scenarios=OrderedDict([('Verify that full dataset vaccination record will be created through ...und=None)], description='', tags={'delete_cleanup_batch', 'vaccine_type_MMR', 'smoke', 'supplier_name_TPP'}, rule=None)\n\n    def pytest_bdd_after_scenario(request, feature, scenario):\n        tags = set(getattr(scenario, 'tags', [])) | set(getattr(feature, 'tags', []))\n        context = request.getfixturevalue('context')\n        get_delete_url_header(context)\n    \n        if 'Delete_cleanUp' in tags:\n            print(f\"\\n Delete Request is {context.url}/{context.ImmsID}\")\n            context.response = requests.delete(f\"{context.url}/{context.ImmsID}\", headers=context.headers)\n            assert context.response.status_code == 204, f\"Expected status code 204, but got {context.response.status_code}. Response: {context.response.json()}\"\n    \n        if 'delete_cleanup_batch' in tags:\n            get_tokens(context, context.supplier_name)\n            context.vaccine_df[\"IMMS_ID_CLEAN\"] = context.vaccine_df[\"IMMS_ID\"].astype(str).str.replace(\"Immunization#\", \"\", regex=False)\n    \n            for imms_id in context.vaccine_df[\"IMMS_ID_CLEAN\"].dropna().unique():\n                delete_url = f\"{context.url}/{imms_id}\"\n                print(f\"Sending DELETE request to: {delete_url}\")\n                response = requests.delete(delete_url, headers=context.headers)\n    \n>               assert response.status_code == 204, (\n                    f\" Failed to delete {imms_id}: expected 204, got {response.status_code}. \"\n                    f\"Response: {response.text}\"\n                )\nE               AssertionError:  Failed to delete nan: expected 204, got 404. Response: {\"resourceType\": \"OperationOutcome\", \"id\": \"23392c1a-5bef-42f6-a204-5eae9e8d4377\", \"meta\": {\"profile\": [\"https://simplifier.net/guide/UKCoreDevelopment2/ProfileUKCore-OperationOutcome\"]}, \"issue\": [{\"severity\": \"error\", \"code\": \"not-found\", \"details\": {\"coding\": [{\"system\": \"https://fhir.nhs.uk/Codesystem/http-error-codes\", \"code\": \"NOT-FOUND\"}]}, \"diagnostics\": \"Immunization resource does not exist. ID: nan\"}]}\nE               assert 404 == 204\nE                +  where 404 = <Response [404]>.status_code\n\nfeatures/conftest.py:97: AssertionError","time":{"start":1764775114072,"stop":1764775160242,"duration":46170}},{"uid":"59ea30bc24d03712","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/171/#testresult/59ea30bc24d03712","status":"passed","time":{"start":1764333508077,"stop":1764333564992,"duration":56915}},{"uid":"4027df7aaae1abac","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/163/#testresult/4027df7aaae1abac","status":"passed","time":{"start":1764003716544,"stop":1764003769230,"duration":52686}},{"uid":"ce31fddb176281c","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/160/#testresult/ce31fddb176281c","status":"broken","statusDetails":"TypeError: fetch_immunization_int_delta_detail_by_immsID() got an unexpected keyword argument 'expected_version'","time":{"start":1763998880964,"stop":1763998934144,"duration":53180}},{"uid":"b9cad6a1ca7a3a0e","reportUrl":"https://NHSDigital.github.io/imms_fhir_api_automation/153/#testresult/b9cad6a1ca7a3a0e","status":"passed","time":{"start":1763047032463,"stop":1763047100305,"duration":67842}}]},"tags":["functional","supplier_name_TPP","vaccine_type_MMR","delete_cleanup_batch","smoke","Create_Batch_Feature"]},"source":"d2c2dd53154aa6d7.json","parameterValues":[]}